use 5.008007;
use Mojolicious::Lite;
use Fcntl ':mode';
use File::Basename 'basename';
use Carp 'croak';
use Validator::Custom;
use Encode qw/encode decode/;

our $VERSION = '0.01';

# Encode
sub e($) { encode('UTF-8', shift) }

my $conf = plugin 'Config';

# Config
my $projectroots = $conf->{projectroots};
my $projectroot = $conf->{projectroots}->[0];
my $projects_list = $conf->{projects_list} //= $projectroot;
my $export_ok = $conf->{export_ok} // '';
my $export_auth_hook = $conf->{export_ok} // undef;
my $GIT = $conf->{git_bindir}
  ? $conf->{git_bindir} . '/git'
  : '/usr/local/bin/git';

my $cgi;
my @diff_opts = ('-M');
my $prevent_xss = 0;

my $default_text_plain_charset  = undef;
my $gitweb_project_owner = undef;

# Validator
my $validator = Validator::Custom->new;
$validator->register_constraint(hex => sub {
  my $value = shift;
  return 0 unless defined $value;
  $value =~ /^[0-9a-fA-F]+$/ ? 1 : 0;
});

get '/' => sub {
  my $self = shift;
  
  my $projectroots = $self->app->config('projectroots');

  $self->render(projectroots => $projectroots);
} => 'projectroots';

get '/projects' => sub {
  my $self = shift;
  
  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  
  my $projectroots = app->config->{projectroots};
  die unless grep { $_ eq $root } @$projectroots;
  
  my @projects = get_projects($root);
  @projects = fill_projects($root, \@projects);
 
  $self->render(projects => \@projects);
} => 'projects';

get '/summary' => sub {
  my $self = shift;
  
  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  
  # HEAd commit
  my $project_description = get_project_description($root, $project);
  my $project_owner = get_project_owner($root, $project);
  my $head_commit = parse_commit($root, $project, "HEAD");
  my %committer_date = %$head_commit
    ? parse_date($head_commit->{committer_epoch}, $head_commit->{committer_tz})
    : ();
  my $last_change = _timestamp_html(\%committer_date);
  my $head_cid = $head_commit->{id};
  my $urls = get_project_urls($root, $project);
  
  # Commits
  my $commit_count = 20;
  my $commits = $head_cid ? parse_commits($root, $project, $head_cid, $commit_count) : ();
  
  # Ref names
  my $ref_names = {};
  my $tag_count = 20;
  my $tags  = get_tags($root, $project, $tag_count);
  $ref_names->{tag}{$_->{id}} = $_->{name} for @$tags;
  my $head_count = 20;
  my $heads = get_heads($root, $project, $head_count);
  $ref_names->{head}{$_->{id}} = $_->{name} for @$heads;
  
  # Render
  $self->render(
    root => $root,
    project => $project,
    project_description => $project_description,
    project_owner => $project_owner,
    last_change => $last_change,
    urls => $urls,
    commits => $commits,
    tags => $tags,
    head_cid => $head_cid,
    heads => $heads,
    ref_names => $ref_names,
    commit_count => $commit_count,
    tag_count => $tag_count,
    head_count => $head_count
  );
};

get '/shortlog' => sub { _log(shift, short => 1) };
get '/log' => sub { _log(shift) };
get '/commit' => sub {
  my $self = shift;

  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = $params->{cid};

  # Project information
  my $project_description = get_project_description($root, $project);
  my $project_owner = get_project_owner($root, $project);
  my %commit = parse_commit($root, $project, $cid);
  my %committer_date = %commit ? parse_date($commit{'committer_epoch'}, $commit{'committer_tz'}) : ();
  my %author_date = %commit ? parse_date($commit{'author_epoch'}, $commit{'author_tz'}) : ();
  $commit{author_date} = _timestamp_html(\%author_date);
  $commit{committer_date} = _timestamp_html(\%committer_date);
  
  # Ref names
  my $ref_names = {};
  my $tags  = get_tags($root, $project);
  $ref_names->{tag}{$_->{id}} = $_->{name} for @$tags;
  my $heads = get_heads($root, $project);
  $ref_names->{head}{$_->{id}} = $_->{name} for @$heads;
  
  my $parent = $commit{parent};
  my $parents = $commit{parents};
  if (!defined $parent) {
    $parent = "--root";
  }
  
  my $difftrees = get_difftree($root, $project, $cid, $parent, $parents);
  
  $self->render(
    root => $root,
    project => $project,
    cid => $cid,
    commit => \%commit,
    ref_names => $ref_names,
    difftrees => $difftrees,
    ref_names => $ref_names
  );
};

get '/commitdiff(:suffix)' => {suffix => ''} => sub {
  my $self = shift;
  
  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => {require => 0 } => ['not_blank'],
    from_cid => {require => 0} => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = defined $params->{cid} ? $params->{cid} : 'HEAD';
  my $from_cid = $params->{from_cid};
  
  # Commit
  my $commit = parse_commit($root, $project, $cid)
    or die 404, "Unknown commit object";
  my %author_date = %$commit
    ? parse_date($commit->{'author_epoch'}, $commit->{'author_tz'})
    : ();
  my %committer_date = %$commit
    ? parse_date($commit->{'committer_epoch'}, $commit->{'committer_tz'})
    : ();
  $commit->{author_date} = _timestamp_html(\%author_date);
  $commit->{committer_date} = _timestamp_html(\%committer_date);
  $from_cid = $commit->{parent} unless defined $from_cid;
  
  # Check plain
  my $plain;
  my $suffix = $self->param('suffix');
  if ($suffix) {
    if ($suffix eq '_plain') { $plain = 1 }
    else { return $self->render('not_found') }
  }
  else { $plain = 0 }
  
  # Plain text
  if ($plain) {
    # git diff-tree plain output
    open my $fd, "-|", git($root, $project), "diff-tree", '-r', @diff_opts,
        '-p', $from_cid, $cid, "--"
      or die 500, "Open git-diff-tree failed";

    my $content = do { local $/; <$fd> };
    my $content_disposition .= "inline; filename=$cid";
    $self->res->headers->content_disposition($content_disposition);
    $self->res->headers->content_type("text/plain");
    $self->render_data($content);
  }
  
  # HTML
  else {
    # git diff-tree output
    open my $fd, "-|", git($root, $project), "diff-tree", '-r', @diff_opts,
        "--no-commit-id", "--patch-with-raw", "--full-index",
        $from_cid, $cid, "--"
      or die 500, "Open git-diff-tree failed";

    # Parse output
    my @diffinfos;
    while (my $line = <$fd>) {
      chomp $line;
      last unless $line;
      push @diffinfos, scalar parse_difftree_raw_line($line);
    }
    
    my $difftrees = get_difftree($root, $project,
      $cid,$commit->{parent}, $commit->{parents});
    
    my @blobdiffs;
    for my $diffinfo (@diffinfos) {
      
      my $from_file = $diffinfo->{'from_file'};
      my $file = $diffinfo->{'to_file'};
      my $from_bid = $diffinfo->{'from_id'};
      my $bid = $diffinfo->{'to_id'};
      
      my @git_diff_tree = (git($root, $project), "diff-tree", '-r',
        @diff_opts, '-p', (!$plain ? "--full-index" : ()), $from_cid, $cid,
        "--", (defined $from_file ? $from_file : ()), $file
      );
      open $fd, "-|", @git_diff_tree
        or die 500, "Open git-diff-tree failed";
      
      my @lines = map { chomp $_; $_ } <$fd>;
      close $fd;
      push @blobdiffs, {lines => \@lines};
    }

    # Ref names
    my $ref_names = {};
    my $tags  = get_tags($root, $project);
    $ref_names->{tag}{$_->{id}} = $_->{name} for @$tags;
    my $heads = get_heads($root, $project);
    $ref_names->{head}{$_->{id}} = $_->{name} for @$heads;
    
    # Render
    $self->render(
      'commitdiff',
      root => $root,
      project => $project,
      cid => $cid,
      commit => $commit,
      difftrees => $difftrees,
      blobdiffs => \@blobdiffs,
      ref_names => $ref_names
    );
  }
};

get '/tree' => sub {
  my $self = shift;

  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => {require => 0 } => ['not_blank'],
    dir => {require => 0 } => ['not_blank'],
    tid => {require => 0 } => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = $params->{cid};
  $cid = "HEAD" unless defined $cid;
  my $dir = $params->{dir};
  my $tid = $params->{tid};

  my $commit = parse_commit($root, $project, $cid);
  
  unless (defined $tid) {
    if (defined $dir) {
      $tid = get_hash_by_path($root, $project, $cid, $dir, "tree");
    }
    else {
      $tid = $commit->{tree};
    }
  }
  die 404, "No such tree" unless defined $tid;

  my @entries = ();
  my $show_sizes = 0;
  {
    local $/ = "\0";
    open my $fd, "-|", git($root, $project), "ls-tree", '-z',
      ($show_sizes ? '-l' : ()), $tid
      or die 500, "Open git-ls-tree failed";
    @entries = map { chomp; $_ } <$fd>;
    close $fd
      or die 404, "Reading tree failed";
  }
  
  my @trees;
  for my $line (@entries) {
    my %tree = parse_ls_tree_line($line, -z => 1, -l => $show_sizes);
    $tree{mode_str} = mode_str($tree{mode});
    push @trees, \%tree;
  }

  $self->render(
    root => $root,
    project => $project,
    cid => $cid,
    tid => $tid,
    commit => $commit,
    trees => \@trees
  );
};

get '/snapshot' => sub {
  my $self = shift;

  require Archive::Tar;
  
  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => {require => 0 } => ['not_blank'],
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = $params->{cid};
  $cid = "HEAD" unless defined $cid;

  # Object type
  my $type = get_object_type($root, $project, "$cid^{}");
  if (!$type) { die 404, 'Object does not exist' }
  elsif ($type eq 'blob') { die 400, 'Object is not a tree-ish' }

  my ($name, $prefix) = snapshot_name($root, $project, $cid);
  my $file = "$name.tar.gz";
  my $cmd = quote_command(
    git($root, $project), 'archive', "--format=tar", "--prefix=$prefix/", $cid
  );
  $cmd .= ' | ' . quote_command('gzip', '-n');

  $file =~ s/(["\\])/\\$1/g;

  open my $fd, "-|", $cmd
    or die 500, "Execute git-archive failed";
  
  # Write chunk
  $self->res->headers->content_type('application/gzip');
  $self->res->headers->content_disposition(qq/attachment; filename="$file"/);
  my $cb;
  $cb = sub {
    my $c = shift;
    my $size = 500 * 1024;
    my $length = sysread($fd, my $buffer, $size);
    unless (defined $length) {
      close $fd;
      undef $cb;
      return;
    }
    $c->write_chunk($buffer, $cb);
  };
  $self->$cb;
};

get '/tag' => sub {
  shift->render(text => 'tag');
};

get '/tags';

get '/heads';

get '/head' => sub {
  shift->render(text => 'head');
};

get '/blob' => sub {
  my $self = shift;

  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => ['not_blank'],
    file => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = $params->{cid};
  my $file = $params->{file};
  
  # Blob id
  my $bid = get_hash_by_path($root, $project, $cid, $file, "blob")
    or die "Cannot find file";
  
  # Blob
  my @git_cat_file = (
    git($root, $project),
    "cat-file",
    "blob",
    $bid
  );
  open my $fd, "-|", @git_cat_file
    or die "Couldn't cat $file, $bid";
  
  my $mimetype = blob_mimetype($fd, $file);

  # Redirect to blob plane
  if ($mimetype !~ m!^(?:text/|image/(?:gif|png|jpeg)$)! && -B $fd) {
    close $fd;
    my $url = $self->url_for('/blob_plain')->query([root => $root, project => $project,
      cid => $cid, file => $file]);
    return $self->refirect_to($url);
  }
  
  # Commit
  my %commit = parse_commit($root, $project, $cid);

  my @lines;
  while (my $line = <$fd>) {
    chomp $line;
    $line = untabify($line);
    push @lines, $line;
  }
  
  $self->render(
    root => $root,
    project => $project,
    cid => $cid,
    bid => $bid,
    file => $file,
    commit => \%commit,
    lines => \@lines
  );
};

get '/blob_plain' => sub {
  my $self = shift;

  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => ['not_blank'],
    file => ['not_blank']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = $params->{cid};
  my $file = $params->{file};

  # Blob id
  my $bid = get_hash_by_path($root, $project, $cid, $file, "blob")
    or die "Cannot find file";
  open my $fd, "-|", git($root, $project), "cat-file", "blob", $bid
    or die "Open git-cat-file blob '$bid' failed";

  # content-type (can include charset)
  my $type = blob_contenttype($fd, $file);

  # "save as" filename, even when no $file is given
  my $save_as = "$cid";
  if (defined $file) {
    $save_as = $file;
  } elsif ($type =~ m/^text\//) {
    $save_as .= '.txt';
  }

  my $sandbox = $prevent_xss &&
    $type !~ m!^(?:text/[a-z]+|image/(?:gif|png|jpeg))(?:[ ;]|$)!;

  # serve text/* as text/plain
  if ($prevent_xss &&
      ($type =~ m!^text/[a-z]+\b(.*)$! ||
       ($type =~ m!^[a-z]+/[a-z]\+xml\b(.*)$! && -T $fd))) {
    my $rest = $1;
    $rest = defined $rest ? $rest : '';
    $type = "text/plain$rest";
  }
  
  my $content = do { local $/ = undef; <$fd> };
  my $content_disposition = $sandbox ? 'attachment' : 'inline';
  $content_disposition .= "; filename=$save_as";
  $self->res->headers->content_disposition($content_disposition);
  $self->res->headers->content_type($type);
  $self->render_data($content);
};

get '/blobdiff(:suffix)' => {suffix => ''} => sub {
  my $self = shift;

  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    cid => ['any'],
    file => ['any'],
    from_cid => ['any'],
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $cid = $params->{cid};
  my $file = $params->{file};
  my $from_cid = $params->{from_cid};
  my $from_file = $params->{from_file};
  
  my $suffix = $self->param('suffix') || '';
  my $plain;
  if ($suffix) {
    if ($suffix eq '_plain') { $plain = 1 }
    else { return $self->render('not_found') }
  }
  else { $plain = 0 }

  my $fd;
  my @difftree;
  my %diffinfo;
  
  my $bid;
  my $from_bid;

  if (defined $cid && defined $from_cid) {
    if (defined $file) {
      # git diff tree
      my @git_diff_tree = (git($root, $project), "diff-tree", '-r',
        @diff_opts, $from_cid, $cid, "--",
        (defined $from_file ? $from_file : ()), $file
      );
      
      open $fd, "-|", @git_diff_tree
        or die 500, "Open git-diff-tree failed";
      @difftree = map { chomp; $_ } <$fd>;
      close $fd
        or die 404, "Reading git-diff-tree failed";
      @difftree
        or die 404, "Blob diff not found";

    } elsif (defined $bid && $bid =~ /[0-9a-fA-F]{40}/) {

      # read filtered raw output
      open $fd, "-|", git($root, $project), "diff-tree", '-r', @diff_opts,
          $from_cid, $cid, "--"
        or die "Open git-diff-tree failed";
      @difftree =
        grep { /^:[0-7]{6} [0-7]{6} [0-9a-fA-F]{40} $bid/ }
        map { chomp; $_ } <$fd>;
      close $fd
        or die("Reading git-diff-tree failed");
      @difftree
        or die("Blob diff not found");

    } else {
      die "Missing one of the blob diff parameters";
    }

    if (@difftree > 1) {
      die "Ambiguous blob diff specification";
    }

    %diffinfo = parse_difftree_raw_line($difftree[0]);
    $from_file ||= $diffinfo{'from_file'} || $file;
    $file   ||= $diffinfo{'to_file'};

    $from_bid ||= $diffinfo{'from_id'};
    $bid        ||= $diffinfo{'to_id'};

    # open patch output
    open $fd, "-|", git($root, $project), "diff-tree", '-r', @diff_opts,
      '-p', (!$plain ? "--full-index" : ()),
      $from_cid, $cid,
      "--", (defined $from_file ? $from_file : ()), $file
      or die_error(500, "Open git-diff-tree failed");
  }
  
  if (!%diffinfo) {
    die '404 Not Found', "Missing one of the blob diff parameters";
  }
  
  my $commit = parse_commit($root, $project, $cid);

  if ($plain) {
    my $content = do { local $/; <$fd> };
    my $content_disposition .= "inline; filename=$file";
    $self->res->headers->content_disposition($content_disposition);
    $self->res->headers->content_type("text/plain");
    $self->render_data($content);
  }
  else {
    # patch
    my @lines;
    while (my $line = <$fd>) {
      chomp $line;
      my $class;
      
      if ($line =~ /^diff \-\-git /) { $class = 'diff header' }
      elsif ($line =~ /^index /) { $class = 'diff extended_header' }
      elsif ($line =~ /^\+/) { $class = 'diff to_file' }
      elsif ($line =~ /^\-/) { $class = 'diff from_file' }
      elsif ($line =~ /^\@\@/) { $class = 'diff chunk_header' }
      else { $class = 'diff' }
      push @lines, {value => $line, class => $class};
    }
    close $fd;

    $self->render(
      '/blobdiff',
      root => $root,
      project => $project,
      cid => $cid,
      from_cid => $from_cid,
      file => $file,
      commit => $commit,
      diffinfo => \%diffinfo,
      lines => \@lines
    );
  }
};

app->start;

sub _log {
  my ($self, %opt) = @_;

  my $short = $opt{short};

  # Validation
  my $raw_params = _params($self);
  my $rule = [
    root => ['not_blank'],
    project => ['not_blank'],
    page => {require => 0} => ['int'],
    base_cid => {require => 0} => ['any']
  ];
  my $vresult = $validator->validate($raw_params, $rule);
  die unless $vresult->is_ok;
  my $params = $vresult->data;
  my $root = $params->{root};
  my $project = $params->{project};
  my $page = $params->{page} || 0;
  $page = 0 if $page < 0;
  
  # HEAD commit
  my $head_commit = parse_commit($root, $project, "HEAD");
  my $head_cid = $head_commit->{id};
  my $base_cid ||= $head_cid;
  
  # Commits
  my $page_count = $short ? 50 : 20;
  my $commits = parse_commits($root, $project, $base_cid, $page_count, $page_count * $page);
  
  # Ref names
  my $ref_names = {};
  my $tags  = get_tags($root, $project);
  $ref_names->{tag}{$_->{id}} = $_->{name} for @$tags;
  my $heads = get_heads($root, $project);
  $ref_names->{head}{$_->{id}} = $_->{name} for @$heads;

  # Render
  my $template = $short ? 'shortlog' : 'log';
  $self->render(
    $template,
    root => $root,
    project => $project,
    head_cid => $head_cid,
    base_cid => $base_cid,
    commits => $commits,
    ref_names => $ref_names,
    page => $page,
    page_count => $page_count
  );
};

sub get_difftree {
  my ($root, $project, $cid, $parent, $parents) = @_;
  
  # Execute "git diff-tree"
  my @git_diff_tree = (
    git($root, $project),
    "diff-tree", '-r',
    "--no-commit-id",
    @diff_opts,
    (@$parents <= 1 ? $parent : '-c'),
    $cid,
    "--"
  );
  open my $fd, "-|", @git_diff_tree
    or die "Open git-diff-tree failed";
  my @difftree = map { chomp; $_ } <$fd>;
  close $fd or die "Reading git-diff-tree failed";
  
  # Parse "git diff-tree" output
  my $diffs = [];
  my @parents = @$parents;
  for my $line (@difftree) {
    my $diff = parsed_difftree_line($line);

    my ($to_mode_oct, $to_mode_str, $to_file_type);
    my ($from_mode_oct, $from_mode_str, $from_file_type);
    if ($diff->{'to_mode'} ne ('0' x 6)) {
      $to_mode_oct = oct $diff->{'to_mode'};
      if (S_ISREG($to_mode_oct)) { # only for regular file
        $to_mode_str = sprintf("%04o", $to_mode_oct & 0777); # permission bits
      }
      $to_file_type = file_type($diff->{'to_mode'});
    }
    if ($diff->{'from_mode'} ne ('0' x 6)) {
      $from_mode_oct = oct $diff->{'from_mode'};
      if (S_ISREG($from_mode_oct)) { # only for regular file
        $from_mode_str = sprintf("%04o", $from_mode_oct & 0777); # permission bits
      }
      $from_file_type = file_type($diff->{'from_mode'});
    }
    
    $diff->{to_mode_str} = $to_mode_str;
    $diff->{to_mode_oct} = $to_mode_oct;
    $diff->{to_file_type} = $to_file_type;
    $diff->{from_mode_str} = $from_mode_str;
    $diff->{from_mode_oct} = $from_mode_oct;
    $diff->{from_file_type} = $from_file_type;

    push @$diffs, $diff;
  }
  
  return $diffs;
}

sub esc_html {
  my $str = shift;
  my %opts = @_;

  return undef unless defined $str;

  $str = $cgi->escapeHTML($str);
  if ($opts{'-nbsp'}) {
    $str =~ s/ /&nbsp;/g;
  }
  $str =~ s|([[:cntrl:]])|(($1 ne "\t") ? quot_cec($1) : $1)|eg;
  return $str;
}

sub esc_path {
  my $str = shift;
  my %opts = @_;

  return undef unless defined $str;

  $str = $cgi->escapeHTML($str);
  if ($opts{'-nbsp'}) {
    $str =~ s/ /&nbsp;/g;
  }
  $str =~ s|([[:cntrl:]])|quot_cec($1)|eg;
  return $str;
}

sub get_projects {
  my ($root, %opt) = @_;
  my $filter = $opt{filter};
  
  opendir my $dh, e$root
    or croak qq/Can't open directory $root: $!/;
  
  my @projects;
  while (my $project = readdir $dh) {
    next unless $project =~ /\.git$/;
    next unless check_export_ok("$root/$project");
    next if defined $filter && $project !~ /\Q$filter\E/;
    push @projects, { path => $project };
  }

  return @projects;
}

sub get_project_description {
  my ($root, $project) = @_;
  return get_file_or_project_config($root, $project, 'description');
}

sub get_file_or_project_config {
  my ($root, $project, $name) = @_;

  my $git_dir = "$root/$project";
  open my $fd, '<', "$git_dir/$name"
    or return ;
  my $conf = <$fd>;
  close $fd;
  if (defined $conf) {
    chomp $conf;
  }
  return $conf;
}

sub check_export_ok {
  my ($dir) = @_;
  return (check_head_link($dir) &&
    (!$export_ok || -e "$dir/$export_ok") &&
    (!$export_auth_hook || $export_auth_hook->($dir)));
}

sub check_head_link {
  my ($dir) = @_;
  my $headfile = "$dir/HEAD";
  return ((-e $headfile) ||
    (-l $headfile && readlink($headfile) =~ /^refs\/heads\//));
}

sub age_class {
  my $age = shift;

  if (!defined $age) {
    return "noage";
  } elsif ($age < 60*60*2) {
    return "age0";
  } elsif ($age < 60*60*24*2) {
    return "age1";
  } else {
    return "age2";
  }
}

use constant {
  S_IFINVALID => 0030000,
  S_IFGITLINK => 0160000,
};

# submodule/subproject, a commit object reference
sub S_ISGITLINK {
  my $mode = shift;

  return (($mode & S_IFMT) == S_IFGITLINK)
}

# convert file mode in octal to symbolic file mode string
sub mode_str {
  my $mode = oct shift;

  if (S_ISGITLINK($mode)) {
    return 'm---------';
  } elsif (S_ISDIR($mode & S_IFMT)) {
    return 'drwxr-xr-x';
  } elsif (S_ISLNK($mode)) {
    return 'lrwxrwxrwx';
  } elsif (S_ISREG($mode)) {
    # git cares only about the executable bit
    if ($mode & S_IXUSR) {
      return '-rwxr-xr-x';
    } else {
      return '-rw-r--r--';
    };
  } else {
    return '----------';
  }
}

# convert file mode in octal to file type string
sub file_type {
  my $mode = shift;

  if ($mode !~ m/^[0-7]+$/) {
    return $mode;
  } else {
    $mode = oct $mode;
  }

  if (S_ISGITLINK($mode)) {
    return "submodule";
  } elsif (S_ISDIR($mode & S_IFMT)) {
    return "directory";
  } elsif (S_ISLNK($mode)) {
    return "symlink";
  } elsif (S_ISREG($mode)) {
    return "file";
  } else {
    return "unknown";
  }
}

# convert file mode in octal to file type description string
sub file_type_long {
  my $mode = shift;

  if ($mode !~ m/^[0-7]+$/) {
    return $mode;
  } else {
    $mode = oct $mode;
  }

  if (S_ISGITLINK($mode)) {
    return "submodule";
  } elsif (S_ISDIR($mode & S_IFMT)) {
    return "directory";
  } elsif (S_ISLNK($mode)) {
    return "symlink";
  } elsif (S_ISREG($mode)) {
    if ($mode & S_IXUSR) {
      return "executable";
    } else {
      return "file";
    };
  } else {
    return "unknown";
  }
}

sub quote_command {
  return join(' ',
    map { my $a = $_; $a =~ s/(['!])/'\\$1'/g; "'$a'" } @_ );
}

sub get_head_hash {
  my ($root, $project) = (shift, shift);
  return get_hash($root, $project, 'HEAD');
}

sub get_head_id {
  my ($root, $project) = (shift, shift);
  return get_id($root, $project, 'HEAD', @_);
};

sub get_id {
  my ($root, $project, $ref, @options) = @_;
  
  my $id;
  my $git_dir = "$root/$project";
  if (open my $fd, '-|', git($root, $project), 'rev-parse',
      '--verify', '-q', @options, $ref) {
    $id = <$fd>;
    chomp $id if defined $id;
    close $fd;
  }
  return $id;
}

sub get_short_hash {
  my ($root, $project) = (shift, shift);
  return get_hash($root, $project, @_, '--short=7');
}

sub get_hash {
  my ($root, $project, $cid, @options) = @_;
  my $git_dir = "$root/$project";
  my $o_git_dir = $git_dir;
  my $retval = undef;
  if (open my $fd, '-|', git_cmd(), 'rev-parse',
      '--verify', '-q', @options, $cid) {
    $retval = <$fd>;
    chomp $retval if defined $retval;
    close $fd;
  }
  if (defined $o_git_dir) {
    $git_dir = $o_git_dir;
  }
  return $retval;
}

sub get_object_type {
  my ($root, $project, $cid) = @_;

  open my $fd, "-|", git($root, $project), "cat-file", '-t', $cid or return;
  my $type = <$fd>;
  close $fd or return;
  chomp $type;
  return $type;
}

# store multiple values for single key as anonymous array reference
# single values stored directly in the hash, not as [ <value> ]
sub hash_set_multi {
  my ($cid, $key, $value) = @_;

  if (!exists $cid->{$key}) {
    $cid->{$key} = $value;
  } elsif (!ref $cid->{$key}) {
    $cid->{$key} = [ $cid->{$key}, $value ];
  } else {
    push @{$cid->{$key}}, $value;
  }
}



# convert config value to boolean: 'true' or 'false'
# no value, number > 0, 'true' and 'yes' values are true
# rest of values are treated as false (never as error)
sub config_to_bool {
  my $val = shift;

  return 1 if !defined $val;             # section.key

  # strip leading and trailing whitespace
  $val =~ s/^\s+//;
  $val =~ s/\s+$//;

  return (($val =~ /^\d+$/ && $val) ||   # section.key = 1
          ($val =~ /^(?:true|yes)$/i));  # section.key = true
}

# convert config value to simple decimal number
# an optional value suffix of 'k', 'm', or 'g' will cause the value
# to be multiplied by 1024, 1048576, or 1073741824
sub config_to_int {
  my $val = shift;

  # strip leading and trailing whitespace
  $val =~ s/^\s+//;
  $val =~ s/\s+$//;

  if (my ($num, $unit) = ($val =~ /^([0-9]*)([kmg])$/i)) {
    $unit = lc($unit);
    # unknown unit is treated as 1
    return $num * ($unit eq 'g' ? 1073741824 :
                   $unit eq 'm' ?    1048576 :
                   $unit eq 'k' ?       1024 : 1);
  }
  return $val;
}

# convert config value to array reference, if needed
sub config_to_multi {
  my $val = shift;

  return ref($val) ? $val : (defined($val) ? [ $val ] : []);
}

sub get_hash_by_path {
  my ($root, $project, $id, $path, $type) = @_;

  $path =~ s,/+$,,;
  
  my @git_ls_tree = (
    git($root, $project), "ls-tree", $id, "--", $path
  );
  
  warn join(' ', @git_ls_tree);
  
  open my $fd, "-|", @git_ls_tree
    or die "Open git-ls-tree failed";
  my $line = <$fd>;
  close $fd or return undef;

  if (!defined $line) {
    # there is no tree or hash given by $path at $base
    return undef;
  }

  $line =~ m/^([0-9]+) (.+) ([0-9a-fA-F]{40})\t/;
  if (defined $type && $type ne $2) {
    # type doesn't match
    return undef;
  }
  return $3;
}

sub get_project_urls {
  my ($root, $project) = @_;

  my $git_dir = "$root/$project";
  open my $fd, '<', "$git_dir/cloneurl"
    or return;
  my @urls = map { chomp; $_ } <$fd>;
  close $fd;

  return \@urls;
}

sub parse_tag {
  my $tag_id = shift;
  my %tag;
  my @comment;

  open my $fd, "-|", git_cmd(), "cat-file", "tag", $tag_id or return;
  $tag{'id'} = $tag_id;
  while (my $line = <$fd>) {
    chomp $line;
    if ($line =~ m/^object ([0-9a-fA-F]{40})$/) {
      $tag{'object'} = $1;
    } elsif ($line =~ m/^type (.+)$/) {
      $tag{'type'} = $1;
    } elsif ($line =~ m/^tag (.+)$/) {
      $tag{'name'} = $1;
    } elsif ($line =~ m/^tagger (.*) ([0-9]+) (.*)$/) {
      $tag{'author'} = $1;
      $tag{'author_epoch'} = $2;
      $tag{'author_tz'} = $3;
      if ($tag{'author'} =~ m/^([^<]+) <([^>]*)>/) {
        $tag{'author_name'}  = $1;
        $tag{'author_email'} = $2;
      } else {
        $tag{'author_name'} = $tag{'author'};
      }
    } elsif ($line =~ m/--BEGIN/) {
      push @comment, $line;
      last;
    } elsif ($line eq "") {
      last;
    }
  }
  push @comment, <$fd>;
  $tag{'comment'} = \@comment;
  close $fd or return;
  if (!defined $tag{'name'}) {
    return
  };
  return %tag
}

sub parse_commits {
  my ($root, $project, $cid, $maxcount, $skip, $file, @args) = @_;

  # git rev-list
  $maxcount ||= 1;
  $skip ||= 0;
  open my $fd, "-|", git($root, $project), "rev-list",
    "--header",
    @args,
    ("--max-count=" . $maxcount),
    ("--skip=" . $skip),
    $cid,
    "--",
    ($file ? ($file) : ())
    or die_error(500, "Open git-rev-list failed");

  # Parse rev-list results
  local $/ = "\0";
  my @commits;
  while (my $line = <$fd>) {
    my %commit = parse_commit_text($line);
    push @commits, \%commit;
  }
  close $fd;

  return \@commits;
}

sub parse_difftree_raw_line {
  my $line = shift;
  my %res;

  if ($line =~ m/^:([0-7]{6}) ([0-7]{6}) ([0-9a-fA-F]{40}) ([0-9a-fA-F]{40}) (.)([0-9]{0,3})\t(.*)$/) {
    $res{'from_mode'} = $1;
    $res{'to_mode'} = $2;
    $res{'from_id'} = $3;
    $res{'to_id'} = $4;
    $res{'status'} = $5;
    $res{'similarity'} = $6;
    if ($res{'status'} eq 'R' || $res{'status'} eq 'C') { # renamed or copied
      ($res{'from_file'}, $res{'to_file'}) = map { unquote($_) } split("\t", $7);
    } else {
      $res{'from_file'} = $res{'to_file'} = $res{'file'} = unquote($7);
    }
  }
  elsif ($line =~ s/^(::+)((?:[0-7]{6} )+)((?:[0-9a-fA-F]{40} )+)([a-zA-Z]+)\t(.*)$//) {
    $res{'nparents'}  = length($1);
    $res{'from_mode'} = [ split(' ', $2) ];
    $res{'to_mode'} = pop @{$res{'from_mode'}};
    $res{'from_id'} = [ split(' ', $3) ];
    $res{'to_id'} = pop @{$res{'from_id'}};
    $res{'status'} = [ split('', $4) ];
    $res{'to_file'} = unquote($5);
  }
  # 'c512b523472485aef4fff9e57b229d9d243c967f'
  elsif ($line =~ m/^([0-9a-fA-F]{40})$/) {
    $res{'commit'} = $1;
  }

  return wantarray ? %res : \%res;
}

sub parsed_difftree_line {
  my $line_or_ref = shift;

  if (ref($line_or_ref) eq "HASH") {
    # pre-parsed (or generated by hand)
    return $line_or_ref;
  } else {
    return parse_difftree_raw_line($line_or_ref);
  }
}

sub parse_ls_tree_line {
  my $line = shift;
  my %opts = @_;
  my %res;

  if ($opts{'-l'}) {
    #'100644 blob 0fa3f3a66fb6a137f6ec2c19351ed4d807070ffa   16717  panic.c'
    $line =~ m/^([0-9]+) (.+) ([0-9a-fA-F]{40}) +(-|[0-9]+)\t(.+)$/s;

    $res{'mode'} = $1;
    $res{'type'} = $2;
    $res{'hash'} = $3;
    $res{'size'} = $4;
    if ($opts{'-z'}) {
      $res{'name'} = $5;
    } else {
      $res{'name'} = unquote($5);
    }
  } else {
    #'100644 blob 0fa3f3a66fb6a137f6ec2c19351ed4d807070ffa  panic.c'
    $line =~ m/^([0-9]+) (.+) ([0-9a-fA-F]{40})\t(.+)$/s;

    $res{'mode'} = $1;
    $res{'type'} = $2;
    $res{'hash'} = $3;
    if ($opts{'-z'}) {
      $res{'name'} = $4;
    } else {
      $res{'name'} = unquote($4);
    }
  }

  return wantarray ? %res : \%res;
}

sub get_heads {
  my ($root, $project, $limit, @classes) = @_;
  @classes = ('heads') unless @classes;
  my @patterns = map { "refs/$_" } @classes;
  my @headslist;

  open my $fd, '-|', git($root, $project), 'for-each-ref',
    ($limit ? '--count='.($limit+1) : ()), '--sort=-committerdate',
    '--format=%(objectname) %(refname) %(subject)%00%(committer)',
    @patterns
    or return;
  while (my $line = <$fd>) {
    my %ref_item;

    chomp $line;
    my ($refinfo, $committerinfo) = split(/\0/, $line);
    my ($cid, $name, $title) = split(' ', $refinfo, 3);
    my ($committer, $epoch, $tz) =
      ($committerinfo =~ /^(.*) ([0-9]+) (.*)$/);
    $ref_item{'fullname'}  = $name;
    $name =~ s!^refs/(?:head|remote)s/!!;

    $ref_item{'name'}  = $name;
    $ref_item{'id'}    = $cid;
    $ref_item{'title'} = $title || '(no commit message)';
    $ref_item{'epoch'} = $epoch;
    if ($epoch) {
      $ref_item{'age'} = age_string(time - $ref_item{'epoch'});
    } else {
      $ref_item{'age'} = "unknown";
    }

    push @headslist, \%ref_item;
  }
  close $fd;

  return \@headslist;
}

sub git_get_tags_list {
  my $limit = shift;
  my @tagslist;

  open my $fd, '-|', git_cmd(), 'for-each-ref',
    ($limit ? '--count='.($limit+1) : ()), '--sort=-creatordate',
    '--format=%(objectname) %(objecttype) %(refname) '.
    '%(*objectname) %(*objecttype) %(subject)%00%(creator)',
    'refs/tags'
    or return;
  while (my $line = <$fd>) {
    my %ref_item;

    chomp $line;
    my ($refinfo, $creatorinfo) = split(/\0/, $line);
    my ($id, $type, $name, $refid, $reftype, $title) = split(' ', $refinfo, 6);
    my ($creator, $epoch, $tz) =
      ($creatorinfo =~ /^(.*) ([0-9]+) (.*)$/);
    $ref_item{'fullname'} = $name;
    $name =~ s!^refs/tags/!!;

    $ref_item{'type'} = $type;
    $ref_item{'id'} = $id;
    $ref_item{'name'} = $name;
    if ($type eq "tag") {
      $ref_item{'subject'} = $title;
      $ref_item{'reftype'} = $reftype;
      $ref_item{'refid'}   = $refid;
    } else {
      $ref_item{'reftype'} = $type;
      $ref_item{'refid'}   = $id;
    }

    if ($type eq "tag" || $type eq "commit") {
      $ref_item{'epoch'} = $epoch;
      if ($epoch) {
        $ref_item{'age'} = age_string(time - $ref_item{'epoch'});
      } else {
        $ref_item{'age'} = "unknown";
      }
    }

    push @tagslist, \%ref_item;
  }
  close $fd;

  return wantarray ? @tagslist : \@tagslist;
}

sub get_tags {
  my ($root, $project, $limit) = @_;
  my @tagslist;

  open my $fd, '-|', git($root, $project), 'for-each-ref',
    ($limit ? '--count='.($limit+1) : ()), '--sort=-creatordate',
    '--format=%(objectname) %(objecttype) %(refname) '.
    '%(*objectname) %(*objecttype) %(subject)%00%(creator)',
    'refs/tags'
    or return;
  while (my $line = <$fd>) {
    my %ref_item;

    chomp $line;
    my ($refinfo, $creatorinfo) = split(/\0/, $line);
    my ($id, $type, $name, $refid, $reftype, $title) = split(' ', $refinfo, 6);
    my ($creator, $epoch, $tz) =
      ($creatorinfo =~ /^(.*) ([0-9]+) (.*)$/);
    $ref_item{'fullname'} = $name;
    $name =~ s!^refs/tags/!!;

    $ref_item{'type'} = $type;
    $ref_item{'id'} = $id;
    $ref_item{'name'} = $name;
    if ($type eq "tag") {
      $ref_item{'subject'} = $title;
      $ref_item{'reftype'} = $reftype;
      $ref_item{'refid'}   = $refid;
    } else {
      $ref_item{'reftype'} = $type;
      $ref_item{'refid'}   = $id;
    }

    if ($type eq "tag" || $type eq "commit") {
      $ref_item{'epoch'} = $epoch;
      if ($epoch) {
        $ref_item{'age'} = age_string(time - $ref_item{'epoch'});
      } else {
        $ref_item{'age'} = "unknown";
      }
    }

    push @tagslist, \%ref_item;
  }
  close $fd;

  return \@tagslist;
}

# assume that file exists
sub insert_file {
  my $file = shift;

  open my $fd, '<', $file;
  print <$fd>;
  close $fd;
}

sub blob_mimetype {
  my $fd = shift;
  my $file = shift;

  # just in case
  return 'text/plain' unless $fd;

  if (-T $fd) {
    return 'text/plain';
  } elsif (! $file) {
    return 'application/octet-stream';
  } elsif ($file =~ m/\.png$/i) {
    return 'image/png';
  } elsif ($file =~ m/\.gif$/i) {
    return 'image/gif';
  } elsif ($file =~ m/\.jpe?g$/i) {
    return 'image/jpeg';
  } else {
    return 'application/octet-stream';
  }
}

sub blob_contenttype {
  my ($fd, $file, $type) = @_;

  $type ||= blob_mimetype($fd, $file);
  if ($type eq 'text/plain' && defined $default_text_plain_charset) {
    $type .= "; charset=$default_text_plain_charset";
  }

  return $type;
}

sub get_content_type_html {
  # require explicit support from the UA if we are to send the page as
  # 'application/xhtml+xml', otherwise send it as plain old 'text/html'.
  # we have to do this because MSIE sometimes globs '*/*', pretending to
  # support xhtml+xml but choking when it gets what it asked for.
  if (defined $cgi->http('HTTP_ACCEPT') &&
      $cgi->http('HTTP_ACCEPT') =~ m/(,|;|\s|^)application\/xhtml\+xml(,|;|\s|$)/ &&
      $cgi->Accept('application/xhtml+xml') != 0) {
    return 'application/xhtml+xml';
  } else {
    return 'text/html';
  }
}

sub _timestamp_html {
  my $date = shift;
  my $strtime = $date->{'rfc2822'};

  my (undef, undef, $datetime_class);
  if ($datetime_class) {
    $strtime = qq!<span class="$datetime_class">$strtime</span>!;
  }

  my $localtime_format = '(%02d:%02d %s)';
  if ($date->{'hour_local'} < 6) {
    $localtime_format = '(<span class="atnight">%02d:%02d</span> %s)';
  }
  $strtime .= ' ' .
              sprintf($localtime_format,
                      $date->{'hour_local'}, $date->{'minute_local'}, $date->{'tz_local'});

  return $strtime;
}

sub normalize_link_target {
  my ($link_target, $basedir) = @_;

  # absolute symlinks (beginning with '/') cannot be normalized
  return if (substr($link_target, 0, 1) eq '/');

  # normalize link target to path from top (root) tree (dir)
  my $path;
  if ($basedir) {
    $path = $basedir . '/' . $link_target;
  } else {
    # we are in top (root) tree (dir)
    $path = $link_target;
  }

  # remove //, /./, and /../
  my @path_parts;
  for my $part (split('/', $path)) {
    # discard '.' and ''
    next if (!$part || $part eq '.');
    # handle '..'
    if ($part eq '..') {
      if (@path_parts) {
        pop @path_parts;
      } else {
        # link leads outside repository (outside top dir)
        return;
      }
    } else {
      push @path_parts, $part;
    }
  }
  $path = join('/', @path_parts);

  return $path;
}

sub fill_from_file_info {
  my ($diff, @parents) = @_;

  $diff->{'from_file'} = [];
  $diff->{'from_file'}[$diff->{'nparents'} - 1] = undef;
  for (my $i = 0; $i < $diff->{'nparents'}; $i++) {
    if ($diff->{'status'}[$i] eq 'R' ||
        $diff->{'status'}[$i] eq 'C') {
      $diff->{'from_file'}[$i] =
        git_get_path_by_hash($parents[$i], $diff->{'from_id'}[$i]);
    }
  }

  return $diff;
}

sub is_deleted {
  my $diffinfo = shift;

  return $diffinfo->{'to_id'} eq ('0' x 40);
}

sub is_patch_split {
  my ($diffinfo, $patchinfo) = @_;

  return defined $diffinfo && defined $patchinfo
    && $diffinfo->{'to_file'} eq $patchinfo->{'to_file'};
}

sub esc_param {
  my $str = shift;
  return undef unless defined $str;
  $str =~ s/([^A-Za-z0-9\-_.~()\/:@ ]+)/CGI::escape($1)/eg;
  $str =~ s/ /\+/g;
  return $str;
}

sub unquote {
  my $str = shift;

  sub unq {
    my $seq = shift;
    my %es = ( # character escape codes, aka escape sequences
      't' => "\t",   # tab            (HT, TAB)
      'n' => "\n",   # newline        (NL)
      'r' => "\r",   # return         (CR)
      'f' => "\f",   # form feed      (FF)
      'b' => "\b",   # backspace      (BS)
      'a' => "\a",   # alarm (bell)   (BEL)
      'e' => "\e",   # escape         (ESC)
      'v' => "\013", # vertical tab   (VT)
    );

    if ($seq =~ m/^[0-7]{1,3}$/) {
      # octal char sequence
      return chr(oct($seq));
    } elsif (exists $es{$seq}) {
      # C escape sequence, aka character escape code
      return $es{$seq};
    }
    # quoted ordinary character
    return $seq;
  }

  if ($str =~ m/^"(.*)"$/) {
    # needs unquoting
    $str = $1;
    $str =~ s/\\([^0-7]|[0-7]{1,3})/unq($1)/eg;
  }
  return $str;
}

sub _tags_body {
  # uses global variable $project
  my ($taglist, $from, $to, $extra) = @_;
  $from = 0 unless defined $from;
  $to = $#{$taglist} if (!defined $to || $#{$taglist} < $to);

  print "<table class=\"tags\">\n";
  my $alternate = 1;
  for (my $i = $from; $i <= $to; $i++) {
    my $entry = $taglist->[$i];
    my %tag = %$entry;
    my $comment = $tag{'subject'};
    my $comment_short;
    if (defined $comment) {
      $comment_short = _chop_str($comment, 30, 5);
    }
    if ($alternate) {
      print "<tr class=\"dark\">\n";
    } else {
      print "<tr class=\"light\">\n";
    }
    $alternate ^= 1;
    if (defined $tag{'age'}) {
      print "<td><i>$tag{'age'}</i></td>\n";
    } else {
      print "<td></td>\n";
    }
    print "<td>" .
          $cgi->a({-href => href(action=>$tag{'reftype'}, hash=>$tag{'refid'}),
                   -class => "list name"}, esc_html($tag{'name'})) .
          "</td>\n" .
          "<td>";
    if (defined $comment) {
      print format_subject_html($comment, $comment_short,
                                href(action=>"tag", hash=>$tag{'id'}));
    }
    print "</td>\n" .
          "<td class=\"selflink\">";
    if ($tag{'type'} eq "tag") {
      print $cgi->a({-href => href(action=>"tag", hash=>$tag{'id'})}, "tag");
    } else {
      print "&nbsp;";
    }
    print "</td>\n" .
          "<td class=\"link\">" . " | " .
          $cgi->a({-href => href(action=>$tag{'reftype'}, hash=>$tag{'refid'})}, $tag{'reftype'});
    if ($tag{'reftype'} eq "commit") {
      print " | " . $cgi->a({-href => href(action=>"shortlog", hash=>$tag{'fullname'})}, "shortlog") .
            " | " . $cgi->a({-href => href(action=>"log", hash=>$tag{'fullname'})}, "log");
    } elsif ($tag{'reftype'} eq "blob") {
      print " | " . $cgi->a({-href => href(action=>"blob_plain", hash=>$tag{'refid'})}, "raw");
    }
    print "</td>\n" .
          "</tr>";
  }
  if (defined $extra) {
    print "<tr>\n" .
          "<td colspan=\"5\">$extra</td>\n" .
          "</tr>\n";
  }
  print "</table>\n";
}

sub _heads_body {
  # uses global variable $project
  my ($headlist, $head_at, $from, $to, $extra) = @_;
  $from = 0 unless defined $from;
  $to = $#{$headlist} if (!defined $to || $#{$headlist} < $to);

  print "<table class=\"heads\">\n";
  my $alternate = 1;
  for (my $i = $from; $i <= $to; $i++) {
    my $entry = $headlist->[$i];
    my %ref = %$entry;
    my $curr = defined $head_at && $ref{'id'} eq $head_at;
    if ($alternate) {
      print "<tr class=\"dark\">\n";
    } else {
      print "<tr class=\"light\">\n";
    }
    $alternate ^= 1;
    print "<td><i>$ref{'age'}</i></td>\n" .
          ($curr ? "<td class=\"current_head\">" : "<td>") .
          $cgi->a({-href => href(action=>"shortlog", hash=>$ref{'fullname'}),
                   -class => "list name"},esc_html($ref{'name'})) .
          "</td>\n" .
          "<td class=\"link\">" .
          $cgi->a({-href => href(action=>"shortlog", hash=>$ref{'fullname'})}, "shortlog") . " | " .
          $cgi->a({-href => href(action=>"log", hash=>$ref{'fullname'})}, "log") . " | " .
          $cgi->a({-href => href(action=>"tree", hash=>$ref{'fullname'}, hash_base=>$ref{'fullname'})}, "tree") .
          "</td>\n" .
          "</tr>";
  }
  if (defined $extra) {
    print "<tr>\n" .
          "<td colspan=\"3\">$extra</td>\n" .
          "</tr>\n";
  }
  print "</table>\n";
}

sub untabify {
  my $line = shift;

  while ((my $pos = index($line, "\t")) != -1) {
    if (my $count = (8 - ($pos % 8))) {
      my $spaces = ' ' x $count;
      $line =~ s/\t/$spaces/;
    }
  }

  return $line;
}

sub _tag {
  my ($root, $project) = @_;
  
  my $cid;
  
  my %tag = parse_tag($cid);

  if (! %tag) {
    die_error(404, "Unknown tag object");
  }

  my $head = get_head_hash($root, $project);
  git_header_html();
  print "<div class=\"title_text\">\n" .
        "<table class=\"object_header\">\n" .
        "<tr>\n" .
        "<td>object</td>\n" .
        "<td>" . $cgi->a({-class => "list", -href => href(action=>$tag{'type'}, hash=>$tag{'object'})},
                         $tag{'object'}) . "</td>\n" .
        "<td class=\"link\">" . $cgi->a({-href => href(action=>$tag{'type'}, hash=>$tag{'object'})},
                                        $tag{'type'}) . "</td>\n" .
        "</tr>\n";
  if (defined($tag{'author'})) {
  }
  print "</table>\n\n" .
        "</div>\n";
  print "<div class=\"page_body\">";
  my $comment = $tag{'comment'};
  for my $line (@$comment) {
    chomp $line;
    print esc_html($line, -nbsp=>1) . "<br/>\n";
  }
  print "</div>\n";
  git_footer_html();
}

sub _tags {
  my ($root, $project) = @_;
  
  my $head = get_head_hash($root, $project);
  git_header_html();

  my @tagslist = git_get_tags_list();
  if (@tagslist) {
    git_tags_body(\@tagslist);
  }
  git_footer_html();
}

sub _heads {
  my ($root, $project);
  
  my $head = get_head_hash($root, $project);
  git_header_html();

  my @headslist = get_heads($root, $project);
  if (@headslist) {
    git_heads_body(\@headslist, $head);
  }
  git_footer_html();
}

sub snapshot_name {
  my ($root, $project, $cid) = @_;

  my $name = $project;
  $name =~ s,([^/])/*\.git$,$1,;
  $name = basename($name);
  # sanitize name
  $name =~ s/[[:cntrl:]]/?/g;

  my $ver = $cid;
  if ($cid =~ /^[0-9a-fA-F]+$/) {
    my $full_hash = get_hash($root, $project, $cid);
    if ($full_hash =~ /^$cid/ && length($cid) > 7) {
      $ver = git_get_short_hash($project, $cid);
    }
  } elsif ($cid =~ m!^refs/tags/(.*)$!) {
    $ver = $1;
  } else {
    if ($cid =~ m!^refs/(?:heads|remotes)/(.*)$!) {
      $ver = $1;
    }
    $ver .= '-' . git_get_short_hash($project, $cid);
  }
  $ver =~ s!/!.!g;

  $name = "$name-$ver";

  return wantarray ? ($name, $name) : $name;
}

sub read_config_file {
  my $file = shift;
  return unless defined $file;
  # die if there are errors parsing config file
  if (-e $file) {
    do $file;
    die $@ if $@;
    return 1;
  }
  return;
}

sub parse_date {
  my $epoch = shift;
  my $tz = shift || "-0000";

  my %date;
  my @months = ("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec");
  my @days = ("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
  my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime($epoch);
  $date{'hour'} = $hour;
  $date{'minute'} = $min;
  $date{'mday'} = $mday;
  $date{'day'} = $days[$wday];
  $date{'month'} = $months[$mon];
  $date{'rfc2822'}   = sprintf "%s, %d %s %4d %02d:%02d:%02d +0000",
                       $days[$wday], $mday, $months[$mon], 1900+$year, $hour ,$min, $sec;
  $date{'mday-time'} = sprintf "%d %s %02d:%02d",
                       $mday, $months[$mon], $hour ,$min;
  $date{'iso-8601'}  = sprintf "%04d-%02d-%02dT%02d:%02d:%02dZ",
                       1900+$year, 1+$mon, $mday, $hour ,$min, $sec;

  my ($tz_sign, $tz_hour, $tz_min) =
    ($tz =~ m/^([-+])(\d\d)(\d\d)$/);
  $tz_sign = ($tz_sign eq '-' ? -1 : +1);
  my $local = $epoch + $tz_sign*((($tz_hour*60) + $tz_min)*60);
  ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime($local);
  $date{'hour_local'} = $hour;
  $date{'minute_local'} = $min;
  $date{'tz_local'} = $tz;
  $date{'iso-tz'} = sprintf("%04d-%02d-%02d %02d:%02d:%02d %s",
                            1900+$year, $mon+1, $mday,
                            $hour, $min, $sec, $tz);
  return %date;
}

sub parse_commit {
  my ($root, $project, $id) = @_;
  
  # Git rev-list
  my @git_rev_list = (
    git($root, $project),
    "rev-list",
    "--parents",
    "--header",
    "--max-count=1",
    $id,
    "--"
  );
  open my $fd, "-|", @git_rev_list
    or die "Open git-rev-list failed";
  
  # Parse rev-list result
  local $/ = "\0";
  my %commit = parse_commit_text(<$fd>, 1);
  close $fd;

  return wantarray ? %commit : \%commit;
}

sub parse_commit_text {
  my ($commit_text, $withparents) = @_;
  my @commit_lines = split '\n', $commit_text;
  my %commit;

  pop @commit_lines; # Remove '\0'

  if (! @commit_lines) {
    return;
  }

  my $header = shift @commit_lines;
  if ($header !~ m/^[0-9a-fA-F]{40}/) {
    return;
  }
  ($commit{'id'}, my @parents) = split ' ', $header;
  while (my $line = shift @commit_lines) {
    last if $line eq "\n";
    if ($line =~ m/^tree ([0-9a-fA-F]{40})$/) {
      $commit{'tree'} = $1;
    } elsif ((!defined $withparents) && ($line =~ m/^parent ([0-9a-fA-F]{40})$/)) {
      push @parents, $1;
    } elsif ($line =~ m/^author (.*) ([0-9]+) (.*)$/) {
      $commit{'author'} = $1;
      $commit{'author_epoch'} = $2;
      $commit{'author_tz'} = $3;
      if ($commit{'author'} =~ m/^([^<]+) <([^>]*)>/) {
        $commit{'author_name'}  = $1;
        $commit{'author_email'} = $2;
      } else {
        $commit{'author_name'} = $commit{'author'};
      }
    } elsif ($line =~ m/^committer (.*) ([0-9]+) (.*)$/) {
      $commit{'committer'} = $1;
      $commit{'committer_epoch'} = $2;
      $commit{'committer_tz'} = $3;
      if ($commit{'committer'} =~ m/^([^<]+) <([^>]*)>/) {
        $commit{'committer_name'}  = $1;
        $commit{'committer_email'} = $2;
      } else {
        $commit{'committer_name'} = $commit{'committer'};
      }
    }
  }
  if (!defined $commit{'tree'}) {
    return;
  };
  $commit{'parents'} = \@parents;
  $commit{'parent'} = $parents[0];

  for my $title (@commit_lines) {
    $title =~ s/^    //;
    if ($title ne "") {
      $commit{'title'} = _chop_str($title, 80, 5);
      # remove leading stuff of merges to make the interesting part visible
      if (length($title) > 50) {
        $title =~ s/^Automatic //;
        $title =~ s/^merge (of|with) /Merge ... /i;
        if (length($title) > 50) {
          $title =~ s/(http|rsync):\/\///;
        }
        if (length($title) > 50) {
          $title =~ s/(master|www|rsync)\.//;
        }
        if (length($title) > 50) {
          $title =~ s/kernel.org:?//;
        }
        if (length($title) > 50) {
          $title =~ s/\/pub\/scm//;
        }
      }
      $commit{'title_short'} = _chop_str($title, 50, 5);
      last;
    }
  }
  if (! defined $commit{'title'} || $commit{'title'} eq "") {
    $commit{'title'} = $commit{'title_short'} = '(no commit message)';
  }
  # remove added spaces
  for my $line (@commit_lines) {
    $line =~ s/^    //;
  }
  $commit{'comment'} = \@commit_lines;

  my $age = time - $commit{'committer_epoch'};
  $commit{'age'} = $age;
  $commit{'age_string'} = age_string($age);
  my ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday) = gmtime($commit{'committer_epoch'});
  if ($age > 60*60*24*7*2) {
    $commit{'age_string_date'} = sprintf "%4i-%02u-%02i", 1900 + $year, $mon+1, $mday;
    $commit{'age_string_age'} = $commit{'age_string'};
  } else {
    $commit{'age_string_date'} = $commit{'age_string'};
    $commit{'age_string_age'} = sprintf "%4i-%02u-%02i", 1900 + $year, $mon+1, $mday;
  }
  return %commit;
}

sub age_string {
  my $age = shift;
  my $age_str;

  if ($age > 60*60*24*365*2) {
    $age_str = (int $age/60/60/24/365);
    $age_str .= " years ago";
  } elsif ($age > 60*60*24*(365/12)*2) {
    $age_str = int $age/60/60/24/(365/12);
    $age_str .= " months ago";
  } elsif ($age > 60*60*24*7*2) {
    $age_str = int $age/60/60/24/7;
    $age_str .= " weeks ago";
  } elsif ($age > 60*60*24*2) {
    $age_str = int $age/60/60/24;
    $age_str .= " days ago";
  } elsif ($age > 60*60*2) {
    $age_str = int $age/60/60;
    $age_str .= " hours ago";
  } elsif ($age > 60*2) {
    $age_str = int $age/60;
    $age_str .= " min ago";
  } elsif ($age > 2) {
    $age_str = int $age;
    $age_str .= " sec ago";
  } else {
    $age_str .= " right now";
  }
  return $age_str;
}

sub get_last_activity {
  my ($root, $project) = @_;

  my $fd;
  my @git_command = (
    git($root, $project),
    'for-each-ref',
    '--format=%(committer)',
    '--sort=-committerdate',
    '--count=1',
    'refs/heads'  
  );
  open($fd, "-|", @git_command) or return;
  my $most_recent = <$fd>;
  close $fd or return;
  if (defined $most_recent &&
      $most_recent =~ / (\d+) [-+][01]\d\d\d$/) {
    my $timestamp = $1;
    my $age = time - $timestamp;
    return ($age, age_string($age));
  }
  return (undef, undef);
}

sub _chop_str {
  my $str = shift;
  my $len = shift;
  my $add_len = shift || 10;
  my $where = shift || 'right'; # 'left' | 'center' | 'right'

  # Make sure perl knows it is utf8 encoded so we don't
  # cut in the middle of a utf8 multibyte char.

  # allow only $len chars, but don't cut a word if it would fit in $add_len
  # if it doesn't fit, cut it if it's still longer than the dots we would add
  # remove chopped character entities entirely

  # when chopping in the middle, distribute $len into left and right part
  # return early if chopping wouldn't make string shorter
  if ($where eq 'center') {
    return $str if ($len + 5 >= length($str)); # filler is length 5
    $len = int($len/2);
  } else {
    return $str if ($len + 4 >= length($str)); # filler is length 4
  }

  # regexps: ending and beginning with word part up to $add_len
  my $endre = qr/.{$len}\w{0,$add_len}/;
  my $begre = qr/\w{0,$add_len}.{$len}/;

  if ($where eq 'left') {
    $str =~ m/^(.*?)($begre)$/;
    my ($lead, $body) = ($1, $2);
    if (length($lead) > 4) {
      $lead = " ...";
    }
    return "$lead$body";

  } elsif ($where eq 'center') {
    $str =~ m/^($endre)(.*)$/;
    my ($left, $str)  = ($1, $2);
    $str =~ m/^(.*?)($begre)$/;
    my ($mid, $right) = ($1, $2);
    if (length($mid) > 5) {
      $mid = " ... ";
    }
    return "$left$mid$right";

  } else {
    $str =~ m/^($endre)(.*)$/;
    my $body = $1;
    my $tail = $2;
    if (length($tail) > 4) {
      $tail = "... ";
    }
    return "$body$tail";
  }
}

sub get_project_owner {
  my ($root, $project) = @_;

  return unless defined $root && defined $project;
  my $git_dir = "$root/$project";

  my $owner;

  if (!defined $gitweb_project_owner) {
    get_project_list_from_file($root, $project);
  }

  if (exists $gitweb_project_owner->{$project}) {
    $owner = $gitweb_project_owner->{$project};
  }

  if (!defined $owner) {
    $owner = get_file_owner("$git_dir");
  }

  return $owner;
}

sub get_project_list_from_file {
  my ($root, $project) = @_;
  
  return if (defined $gitweb_project_owner);

  $gitweb_project_owner = {};
  if (-f $projects_list) {
    open(my $fd, '<', $projects_list);
    while (my $line = <$fd>) {
      chomp $line;
      my ($pr, $ow) = split ' ', $line;
      $pr = unescape($pr);
      $ow = unescape($ow);
      $gitweb_project_owner->{$pr} = $ow;
    }
    close $fd;
  }
}

sub parse_project_config {
  my ($root, $project, $section_regexp) = @_;
  my %config;

  local $/ = "\0";

  open my $fh, "-|", git($root, $project), "config", '-z', '-l',
    or return;

  while (my $keyval = <$fh>) {
    chomp $keyval;
    my ($key, $value) = split(/\n/, $keyval, 2);

    hash_set_multi(\%config, $key, $value)
      if (!defined $section_regexp || $key =~ /^(?:$section_regexp)\./o);
  }
  close $fh;

  return %config;
}

sub git {
  my ($root, $project) = @_;
  my $git_dir = "$root/$project";
  
  return ($GIT, "--git-dir=$git_dir");
}

sub get_file_owner {
  my $path = shift;

  my ($dev, $ino, $mode, $nlink, $st_uid, $st_gid, $rdev, $size) = stat($path);
  my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwuid($st_uid);
  if (!defined $gcos) {
    return undef;
  }
  my $owner = $gcos;
  $owner =~ s/[,;].*$//;
  return $owner;
}

sub fill_projects {
  my ($root, $ps) = @_;

  my @projects;
  for my $project (@$ps) {
    my (@activity) = get_last_activity($root, $project->{'path'});
    next unless @activity;
    ($project->{'age'}, $project->{'age_string'}) = @activity;
    if (!defined $project->{'descr'}) {
      my $descr = get_project_description($root, $project->{'path'}) || "";
      $project->{'descr_long'} = $descr;
      $project->{'descr'} = _chop_str($descr, 25, 5);
    }

    push @projects, $project;
  }

  return @projects;
}

sub _params {
  my $c = shift;
  my $params = {map { $_ => scalar $c->param($_) } $c->param};
  return $params;
}


